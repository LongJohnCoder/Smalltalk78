'From Smalltalk 5.5bXM July 4 on 30 July 1979 at 11:33:59 am.'\gObject asFollows\f5bgThingLab Inheritance\f5bgasPrototype | f  "make me be a prototype"	["If I'm already a prototype, just return myself.		Otherwise make a new class for me and return my new self."	self isPrototype[self]	"crock - if I am an object, add some spare fields"	f_[self classObject['part1 part2 part3 part4 part5 part6 part7 part8 part9 part10 part11 part12 part13 part14 part15 part16'] ''].	self asPrototypeWithFields: f]\gb12B6i22I5i107I30i48IasPrototypeWithFields: f  "make me be a prototype with additional fields f"		| name cl fieldProperties i	[self isPrototype[user notify: 'I am already a prototype']	"make a new class for me"	name_Things invert: self.	[name[]  name_user request: 'I need a name!'].	Class new title: name asString		subclassof: self class		fields: f		declare: ''.	SystemOrganization classify: name unique under: 'Prototype Classes'.	cl_Smalltalkname unique.	cl classvars init.  cl md close.	"initialize types of new fields to spare"	fieldProperties _ cl prototype fieldProperties.	for i from: self class instsize+1 to: cl instsize do		[(fieldPropertiesi) type_spare; named_false].	cl prototype copyFrom: self.	cl prototype]\gb26B1i46u1IU2b2B91i23I295i34u5IUcanUnderstand: op | fieldProperties i name	["Return true if one of my superclasses can understand op.		Compile a forwarder if necessary."	self class canUnderstand: op[true]	fieldProperties_self fieldProperties.	for i to: self class instsize do		[(fieldPropertiesi is: SuperclassDescription) and			((self instfield: i) canUnderstand: op)			[namenilfalse[user notify: 'conflicting inherited messages']			name_(fieldPropertiesi) name]].	namenil[false]	"compile a message forwarder"	self compileForwarderFor: op to: name]\gb18B28i53u2U37I337i27IcompileForwarderFor: op to: name | strm vec i	[strm_Stream default.	op numArgs=0		[strm append: op; append: ' ['; append: name; space; 			append: op; append: ']'.		self class understands: strm contents classified: 'Forwarders']	"break up op into keywords"	vec_((op subst: ': ' for: ':') subst: ' ' for: '') asVector.	for i to: vec length do		[strm append: veci; append: ' arg'; print: i; space].	strm append: '['; append: name; space.	for i to: vec length do		[strm append: veci; append: ' arg'; print: i; space].	strm append: ']'.	self class understands: strm contents classified: 'Forwarders']\gb33B204i25IinitPrototype  "I am a prototype.  Initialize myself"		| cl superPrototype i m	[cl_self class.	cl classvars insert: prototype with: self.	Things insert: cl title unique with: self.	"copy inherited fields if any"	clObject[]	superPrototype_cl superclass prototype.	for i to: superPrototype class instsize do		[self instfield: i _ (superPrototype instfield: i) recopy].	"perform inherited merges"	for m from: self merges allentries do		[m mergePartsFor: self]]\gb15B1i36I136i28I167i24IisPrototype   "return true if I am the prototypical instance of my class"	["note that this will work even if there is no prototype"	self(self class classvars lookup: prototype)]\gb14Bi59bI2B1i56Iprototype [self class prototype]\gb10BThingLab Fields\f5bgabsoluteReferences: absoluteReferences | instvars i f	[absoluteReferences_absoluteReferences asVector.  	instvars_self class instvars.	for i to: instvars length do		[absoluteReferences has: (instvarsi) unique			[f_AbsoluteReference new.			self fieldPropertiesi_f.			f name: (instvarsi) unique index: i type: absoluteReference 				named: true.			f compileIn: self]]]\gb39Bfield: n   "return my field named n"	[n is: Integer[self instfield: n]	self perform: n unique]\gb11Bi25bI2Bfield: n replaceWith: value   "replace a field"		| fieldProperties i	[n is: Integer[self instfield: n _ value]	fieldProperties_self fieldProperties.  i_1.	until (i>fieldProperties length or n=(fieldPropertiesi) name) do		[i_i+1].	ifieldProperties length[self instfield: i _ value]	user notify: 'field name not found']\gb30Bi17Ifield: n _ value	[(self field: n) copyFrom: value]\gb18BfieldProperties   "return my vector of instance field properties"		| p i instvars superFields	[p_self class classvars lookup: fieldProperties.	[nilp[] falsep[] p].	instvars_self class instvars.  p_Vector new: instvars length.	"copy inherited fields"	superFields_[self classObject[Vector new: 0]		self class superclass prototype fieldProperties].	for i to: superFields length do		[pi_(superFieldsi) copy].	"KLUDGE! field names are unique for backwards compatability"	for i from: superFields length+1 to: p length do		[pi_Field new name: (instvarsi) unique index: i 			type: primitive named: false].	self class classvars insert: fieldProperties with: p.	p]\gb18Bi47I173i21I169i58IfieldProperty: n | f	[n is: Integer[self fieldPropertiesn]	for f from: self fieldProperties do		[f name=n[f]].	user notify: 'field not found']\gb17B3b2BnameOfField: f   "return a unique string"	[f is: Integer[(self fieldPropertiesf) name]	f]\gb17Bi24InumberOfField: f   "return an offset"		| fieldProperties i	[f is: Integer[f]	fieldProperties_self fieldProperties.  i_1.	until (i>fieldProperties length or f=(fieldPropertiesi) name) do		[i_i+1].	ifieldProperties length[i]	user notify: 'field name not found']\gb19Bi18Iparts | fieldProperties strm i	[fieldProperties_self fieldProperties.	strm_(Vector new: 10) asStream.	for i to: fieldProperties length do		[(fieldPropertiesi) type=part			[strm next_self instfield: i]].	strm contents]\gb6Bparts: parts | instvars i f	[parts_parts asVector.  instvars_self class instvars.	for i to: instvars length do		[parts has: (instvarsi) unique			[f_PartDescription new.			self fieldPropertiesi_f.			f name: (instvarsi) unique index: i type: part named: true.			f compileIn: self]]]\gb13Bprimitives: primitives | instvars i f	[primitives_primitives asVector.  instvars_self class instvars.	for i to: instvars length do		[primitives has: (instvarsi) unique			[f_PartDescription new.			self fieldPropertiesi_f.			f name: (instvarsi) unique index: i type: primitive named: true.			f compileIn: self]]]\gb23BrelativeReferences: relativeReferences | instvars i f	[relativeReferences_relativeReferences asVector.  	instvars_self class instvars.	for i to: instvars length do		[relativeReferences has: (instvarsi) unique			[f_RelativeReference new.			self fieldPropertiesi_f.			f name: (instvarsi) unique index: i type: relativeReference 				named: true.			f compileIn: self]]]\gb39Breplace: path with: value   "replace the field at the end of path"	[self replace: path with: value merges: HashSet init]\gb28Bi33u4U1Ireplace: path with: value merges: merges | merge	["replace the field at the end of path.  merges is a set of merges 		already checked - this prevents infinite looping.		For use by replace:with: message"	"first replace the field indicated by path itself"	self replacePath: path with: value.	"now check for any other paths to the field"	for merge from: (self merges lookupVec: path firstName) do		[self replace: path with: value merges: merges forMerge: merge.		self replaceParts: path with: value merges: merges forMerge: merge]]\gb41B10i33u4U3u6U86u13U9I3i37u4U7I41i42Ireplace: path with: value merges: merges forMerge: merge		| difference p	["replace the field at the end of path for the particular merge constraint		 merge.  merges is a set of merges 		already checked - this prevents infinite looping.		For use by replace:with:merges: message"	(merges has: merge) or (merge hasPath: path)false[]	merges insert: merge.	for p from: merge paths do		[self replace: p with: value merges: merges]]\gb59B17i33u4U40u5U3u6U86u20U9IreplaceParts: path with: value merges: merges forMerge: merge		| difference p part	["the field at the end of path is being merged for the merge constraint		 merge.  check for any parts of the field which have been merged,		and replace each of them with the appropriate part from value.		merges is a set of merges 		already checked - this prevents infinite looping.		For use by replace:with:merges: message"	merges has: merge[]	for p from: merge paths do		[difference_p within: path.		differencefalse[]		merges insert: merge.		part_difference applyTo: value.		for p from: merge paths do			[self replace: p with: part merges: merges].		self  "stop checking paths"]]\gb64B22i25u4U45u5U17b5B96u5U4u6U86u20U9I252i19IreplacePath: path with: value | firstName tail	["replace the field at the end of path, ignoring my merges but not		those of my parts.  For use by replace:with: message"	firstName_path firstName.  tail_path tail.	tail empty[self field: firstName replaceWith: value]	(self field: firstName) replace: tail with: value]\gb30B19i33u4U62u13U9Ispares: spares | instvars i f	[spares_spares asVector.  instvars_self class instvars.	for i to: instvars length do		[spares has: (instvarsi) unique			[f_PartDescription new.			self fieldPropertiesi_f.			f name: (instvarsi) unique index: i type: spare named: false.			f compileIn: self]]]\gb15Bsuperclasses: superclasses | instvars i f	[superclasses_superclasses asVector.  	instvars_self class instvars.	for i to: instvars length do		[superclasses has: (instvarsi) unique			[f_SuperclassDescription new.			self fieldPropertiesi_f.			f name: (instvarsi) unique index: i type: superclass				named: true.			f compileIn: self]]]\gb27BunnamedParts: unnamedParts | instvars i f	[unnamedParts_unnamedParts asVector.  instvars_self class instvars.	for i to: instvars length do		[unnamedParts has: (instvarsi) unique			[f_PartDescription new.			self fieldPropertiesi_f.			f name: (instvarsi) unique index: i type: part named: false.			f compileIn: self]]]\gb27BThingLab Constraints\f5bgchecksFor: queue | message code	[queue empty['']	"Some messages remain after other methods (including relaxation) 		have been tried.  All the constraints for the remaining messages 		should now be satisfied.  However, the program hasn't been able 		to deduce this at compile time.  Put in code for run-time checks."	code_Stream default.	until queue empty do 		[message _ queue1.		message checksTo: code.		message checked: queue].	code contents]\gb17B37i267IcomplexMethod: message queue: queue		| code method copy transform			forwardsCode backwardsCode circularCode checksCode	["Compile a method for receiving message.  A simple linear plan could not		be used.  Ask the message to find all the other messages that		might need to be sent to satisfy the constraints.		After accumulating the queue of messages, build a plan by		seeing which of them actually need to be sent."	code_Stream default.	"First try working forwards, then backwards, and then try the		method for circular methods.  Each of these methods returns		a code string, which will be empty if there was nothing left to do."	forwardsCode_self workForwards: queue.	backwardsCode_self workBackwards: queue.	circularCode_self circularMethod: queue.	checksCode_self checksFor: queue.	queue emptyfalse[user notify: 'queue not empty']	method_message makeMethod.	"build the code for the method"	code append: ' "forwards code" '; cr; append: forwardsCode; 		cr; cr; append: ' "circular code" '; cr; append: circularCode;		cr; cr; append: ' "backwards code" '; cr; append: backwardsCode;		cr; cr; append: ' "checks" '; cr; append: checksCode.	method temps_queue temps contents;		body_code contents;		compileIn: self.	"make a copy of the original message without backpointers"	copy_Message new context: nil receiver: message receiver		constraint: nil owner: EmptyPath		keywords: message keywords arguments: method arguments		uniqueState: message uniqueState referenceOnly: message referenceOnly		compileTimeOnly: message compileTimeOnly.	"make a transformed message from the method"	transform_Message new context: nil receiver: EmptyPath		constraint: nil owner: EmptyPath		keywords: method keywords arguments: method arguments		uniqueState: message uniqueState referenceOnly: message referenceOnly		compileTimeOnly: message compileTimeOnly.	"save this message in my dictionary of constraint satisfaction methods"	self methods insert: copy with: transform.	transform]\gb38B85i32u7U258I25i194I241i31I329i58I269i42I267i69Iconstraints  "return a table of my constraints indexed by first names of paths"		| dict c	[dict_self class classvars lookup: constraints.	[nildict[] falsedict[]  dict].	dict_MultiEntryDict init.	self class classvars insert: constraints with: dict.	[self classObject[]		for c from: self class superclass prototype constraints allentries do			[c insertIn: self]].	dict]\gb13Bi66IequalityConstraint: paths | i	[for i to: paths length-1 do		[self equalityConstraint: pathsi and: paths(i+1)]]\gb26BequalityConstraint: path1 and: path2 		| c name1 name2 ruleStrm key1 key2 mess1 mess2 meth1 meth2 body1 body2	["make up a name"	name1_Stream default.  path1 appendNamesTo: name1.	name1_name1 contents.	name2_Stream default.  path2 appendNamesTo: name2.	name2_name2 contents.	c_self constraint: name1 + 'EQUALS' + name2.	"make up a rule"	ruleStrm_Stream default.	path1 printNamesOn: ruleStrm.  ruleStrm append: '= '.	path2 printNamesOn: ruleStrm.	c rule_ruleStrm contents.	key1_(name1+'GETS'+name2) inVector.	key2_(name2+'GETS'+name1) inVector.	"generate messages"	mess1_Message new context: nil receiver: path1 		constraint: nil owner: EmptyPath		keywords: key1 arguments: ()		uniqueState: true referenceOnly: false compileTimeOnly: false.	mess2_Message new context: nil receiver: path2 		constraint: nil owner: EmptyPath		keywords: key2 arguments: ()		uniqueState: true referenceOnly: false compileTimeOnly: false.	c messages_mess1, mess2.	"generate methods"	body1_Stream default.	path1 codeTo: body1.  body1 append: '_'.  path2 codeTo: body1.	body2_Stream default.	path2 codeTo: body2.  body2 append: '_'.  path1 codeTo: body2.	meth1_Method new keywords: key1		arguments: () temps: () body: body1 contents.	meth2_Method new keywords: key2		arguments: () temps: () body: body2 contents.	c methods_meth1, meth2.	c insertIn: self]	\gb40B74i14I200i14I217i17I392i16Iexpand: message queue: queue | keyword	["If message is a compile time message, expand it.		Kludge - for now, the kinds of compile time messages		are simply build in."	keyword_message keywords1.	keyword='moveby:'		[message receivingObject expandMove: message queue: queue]	keyword='scaleby:'		[message receivingObject expandScale: message queue: queue]	keyword='fixedLocation'		[message receivingObject expandFixedLocation: message queue: queue]	keyword length>12 and keyword(1 to: 12)='moveInserter'		[message receivingObject expandMoveAttacher: message 			queue: queue attachers: self inserters]	keyword length>15 and keyword(1 to: 15)='moveConstrainer'		[message receivingObject expandMoveAttacher: message 			queue: queue attachers: self constrainers]	queue insert: message]\gb29B12i4u7U116IexpandFixedLocation: message queue: queue | f m	["send this message to each of my parts"	for f from: self fieldProperties do		[f type=part			[m_Message new				context: message context 				receiver: (message receiver add: f pathName)				constraint: message constraint owner: message owner				keywords: message keywords arguments: message arguments				uniqueState: message uniqueState				referenceOnly: message referenceOnly				compileTimeOnly: message compileTimeOnly.			(self instfield: f index) expand: m queue: queue]]]\gb42B8i38IexpandMove: message queue: queue | f m	["send this message to each of my parts"	for f from: self fieldProperties do		[f type=part			[m_Message new				context: message context 				receiver: (message receiver add: f pathName)				constraint: message constraint owner: message owner				keywords: message keywords arguments: message arguments				uniqueState: message uniqueState				referenceOnly: message referenceOnly				compileTimeOnly: message compileTimeOnly.			(self instfield: f index) expand: m queue: queue]]]\gb33B8i38IexpandMoveAttacher: message queue: queue attachers: attachers		| n strm char digits i move fix	["the keyword will have the attacher number built in.		Extract the number of the attacher"	strm_(message keywords1) asStream.	char_strm next.	until char isdigit do [char_strm next].	digits_Stream default.	while char isdigit do		[digits next_char.  char_strm next].	n_digits contents asInteger.	"if this is attacher #1 move the entire object"	n=1		[move_Message new			context: message context 			receiver: message receiver			constraint: message constraint owner: message owner			keywords: ('moveby:')			arguments: message arguments			uniqueState: true referenceOnly: false compileTimeOnly: false.		message context expand: move queue: queue]	"fix the attachers already in position, and move all the remaining ones"	for i to: n-1 do		[fix_Message new			context: message context 			receiver: (message receiver concat: attachersi)			constraint: message constraint owner: message owner			keywords: ('fixedLocation')			arguments: ()			uniqueState: true referenceOnly: false compileTimeOnly: true.		message context expand: fix queue: queue].	for i from: n to: attachers length do		[move_Message new			context: message context 			receiver: (message receiver concat: attachersi)			constraint: message constraint owner: message owner			keywords: ('moveby:')			arguments: message arguments			uniqueState: true referenceOnly: false compileTimeOnly: false.		message context expand: move queue: queue]]\gb64B35i88I219i45I313i70IexpandScale: message queue: queue | f m	["send this message to each of my parts"	for f from: self fieldProperties do		[f type=part			[m_Message new				context: message context 				receiver: (message receiver add: f pathName)				constraint: message constraint owner: message owner				keywords: message keywords arguments: message arguments				uniqueState: message uniqueState				referenceOnly: message referenceOnly				compileTimeOnly: message compileTimeOnly.			(self instfield: f index) expand: m queue: queue]]]\gb34B8i38IforegroundSelector: showSelector message: message	["Return a selector for showing my moving foreground, or nil"	nil]\gb51B2i58IforgetConstraintMethods	[self methods init.  self instancePathsDict init]\gb25BmakeMethodFor: message  "Compile a method for receiving message"		| queue m	[queue_MessageQueue init.	self expand: message queue: queue.	"If there is only one message in queue, and if that message		is linear with respect to me, that is, if it doesn't interact with any		of my constraints or merges, then use a simple method."	self testSimple: queue[self simpleMethod: message queue: queue]	"situation not simple - find all the relevant messages"	for m from: queue contents do		[m addMessages: queue].	queue deleteDuplicates.  "delete duplicate messages"	"if there is only 1 message in the queue, use a cheap method"	queue length=1[self oneMessageMethod: message queue: queue]	self complexMethod: message queue: queue]\gb24Bi32u7IU79i32u5U151I71i53I88i25I4i59Imerges   "return a table of my merges indexed by first names of paths"		| dict m	[dict_self class classvars lookup: merges.	[nildict[] falsedict[]  dict].	dict_MultiEntryDict init.	self class classvars insert: merges with: dict.	[self classObject[]		for m from: self class superclass prototype merges allentries do			[m insertIn: self]].	dict]\gb9Bi61Imethods | x   "return my dictionary of constraint satisfaction methods"	["the dictionary consists of messages on the name side of the dictionary,		 and	on the value side the corresponding transformed messages"	x_self class classvars lookup: methods.	[nilx[] falsex[] x].	x_Dictionary init.  self class classvars insert: methods with: x.	x]\gb8B6i56I5i136IoneMessageMethod: message queue: queue | copy queuedMessage	[copy_message noBackPointerCopy.	queuedMessage_(queue1) noBackPointerCopy.	self methods insert: copy with: queuedMessage.	queuedMessage]\gb39BsimpleMethod: message queue: queue		| copy queuedMessage receiver firstName tail field 		subMessage subTransform transform	["Since queue is simple, just make a method which consists 		of sending its message  on to my part."	copy_message noBackPointerCopy.	queuedMessage_(queue1) noBackPointerCopy.	receiver_queuedMessage receiver.	receiver empty		[self methods insert: copy with: queuedMessage. queuedMessage]	firstName_receiver firstName.  tail_receiver tail.	field_self field: firstName.	subMessage_Message new 		context: field receiver: tail		constraint: nil owner: EmptyPath		keywords: queuedMessage keywords		arguments: queuedMessage arguments		uniqueState: queuedMessage uniqueState		referenceOnly: queuedMessage referenceOnly		compileTimeOnly: queuedMessage compileTimeOnly.	subTransform_field transform: subMessage.	transform_Message new 		context: nil		receiver: ((AccessPath new names: firstName inVector) concat: 			subTransform receiver)		constraint: nil owner: EmptyPath		keywords: subTransform keywords		arguments: subTransform arguments		uniqueState: subTransform uniqueState		referenceOnly: subTransform referenceOnly		compileTimeOnly: subTransform compileTimeOnly.	self methods insert: copy with: transform.	transform]\gb37B90i7u5U87ItestSimple: queue | message receiver firstName	["return true if there is only one message in queue, and if that message		is linear with respect to me, that is, if it doesn't interact with any		of my constraints or merges"	queue length>1[false]	message_queue1.	"message is simple if the first name of its receiver doesn't overlap		any of my constraints or merges"	receiver_message receiver.	receiver empty[true]	firstName_receiver firstName.	"use lookup: rather than lookupVec: - just want to see if there are any		constraints or merges"	self constraints lookup: firstName[false]	self merges lookup: firstName[false]	true]\gb18B32i44u5U124I47iu7U94I87i94Itransform: message | transform	["return a new message which takes my constraints into account"	"first check if there is already an appropriate method"	transform_self methods lookup: message[transform]	user displayoffwhile [transform_self makeMethodFor: message].	transform]\gb19B14i63I1i55IworkBackwards: queue | toBeSent message code	[queue empty['']	code_Stream default.	toBeSent_(Vector new: 10) asStream.	message_queue findPostponable.	while message do 		[toBeSent next_message.		message postponed: queue.		message_queue findPostponable].	"generate code"	for message from: toBeSent contents reverse do		[message codeTo: code].	code contents]\gb21B245i15IworkForwards: queue | toBeSent message code	[queue empty['']  code_Stream default.	toBeSent _ (Vector new: 10) asStream.	message _ queue findSendable.	while message do 		[toBeSent next _ message.		message sentNext: queue.		message _ queue findSendable].	"generate code"	for message from: toBeSent contents do [message codeTo: code].	code contents]\gb20B246i15IThingLab Relaxation\f5bgcircularMethod: queue	[queue empty['']	"A linear ordering for the messages in queue couldn't be found.		The default is to use relaxation."	Relaxer new circularMethod: self queue: queue]\gb23B20i39u5U56IlargestRelaxablePart: path	["return a path to the largest of my subparts that can be relaxed"	self largestRelaxablePart: path prefixPath: EmptyPath]\gb28B2i63IlargestRelaxablePart: path prefixPath: prefix | firstName	[path empty[prefix]	"return a path to the largest of my subparts that can be relaxed.		the default is that I am not relaxable - ask my part"	firstName_path firstName.	(self field: firstName) largestRelaxablePart: path tail 		prefixPath: (prefix add: firstName)]\gb46B37i119IminChange   "minimum allowable change during relaxation"	[0.001]\gb12Bi44Itolerance   "for error in constraints"	[1.0e4]\gb12Bi26IThingLab Properties\f5bgcategory: category class: class  "find or create a property table named category"		| table	[category='Properties'[self properties]	table_self properties lookup: category[table]	table_class init name: category.	self properties insert: category with: table.	table]\gb33Bi39u8U1bI3Bmerge: vec | paths constraint cl sameClass i otherClass obj f newPaths p	[paths_Vector new: vec length.	for i to: vec length do		[pathsi_(veci) asPath].	"check if these are primitive parts.  In this case, use equality constraints."	obj_(paths1) allButLast applyTo: self.	f_obj fieldProperty: (paths1) names last.	f type=primitive		[self equalityConstraint: paths]	"since objects must be of the same class to merge, 		if necessary create a series of merges"	cl_(paths1 applyTo: self) class.	sameClass_true.	for i from: 2 to: paths length do		[otherClass_(pathsi applyTo: self) class.		otherClasscl[]		sameClass_false.		"find nearest common ancestor"		until (otherClass Isa: cl) do [cl_cl superclass]].	sameClass		["simple case - all objects to be merged are of the same class"		constraint_MergeConstraint new.		constraint paths_paths; insertIn: self]	cl instsize=0[user notify: 'vacuous merge']	"complex case - for each part inherited from the nearest common		 ancestor, merge the corresponding parts"	for f from: cl prototype fieldProperties do		[newPaths_(Vector new: 10) asStream.		for p from: paths do			[newPaths next_p concat: f asPath].		self merge: newPaths contents]]\gb11B151i76I144i91I177i28I73i60I126i105Ipicture: format  "return a new picture"		| formats name i	[[format Is: String[format_Format new name: format]].	name_format name.	formats_self formats.	i_1.	until (i>formats length or name=(formatsi) name) do		[i_i+1].	"if there is already a like-named format, replace it.		Otherwise append new format"	[iformats length[formatsi_format]  formats_formats, format].	self class classvars insert: formats with: formats.	Picture new name: name]\gb17Bi21I195i82Iproperties | p   "return my table of properties"	[p_self class classvars lookup: properties.	[nilp[] falsep[] p].	p_PropertyTable init name: properties.	self class classvars insert: properties with: p.	p]\gb11B6i31IThingLab Showing\f5bgformats   "return a vector of formats in which I can show myself"		| formats	[formats_self class classvars lookup: formats.	[nilformats or falseformats[] formats].	[self classObject		[formats_			(Format new name: 'structure') ,			(Format new name: 'prototype''s picture') ,			(Format new name: 'prototype''s values') ,			(Format new name: 'as save file') ,			(Format new name: 'subclass template')].	 formats_self class superclass prototype formats copy].	self class classvars insert: formats with: formats.	formats]\gb10Bi55Iname | t	[t_self class title.	self isPrototype[t + ' prototype']	'AEIOU' has: t1['an ' +  t]	'a ' + t]\gb5Bprintfields: strm | i fieldProperties	[fieldProperties_self fieldProperties.	for i to: fieldProperties length do		[fieldPropertiesi printfield: strm field: (self instfield: i)]]\gb18Bprintfieldstructure: strm | i fieldProperties	[fieldProperties_self fieldProperties.	for i to: fieldProperties length do		[fieldPropertiesi printfieldstructure: strm field: (self instfield: i)]]\gb26Bprinttableoffields: strm   "print my name and fields"	[self class instsize=0[self printon: strm]	strm append: self name; indent.	self printfields: strm.	strm unindent]\gb27Bi26Ishowassavefile: window	[window showParagraph: self sourceCode asParagraph]\gb24Bshowdefault: window   "the default is nothing to show"\gb22Bishowdeleted: window | rect	[rect_window screenRectOf: self frame.	rect clear: white.  self showpicture: window.  rect comp]\gb20Bshowlabel: window | i	[for i to: self class instsize do		[(self instfield: i) showlabel: window]]\gb18Bshowlabeledpicture: window	[self showpicture: window; showlabel: window]\gb28Bshowpicture: window | i	[for i to: self class instsize do		[(self instfield: i) showpicture: window]]\gb20Bshowprototypespicture: window	[self showpicture: window; showlabeledpicture: window]\gb32Bshowprototypesvalues: window		| strm	[strm_IndentingStream default.	self printtableoffields: strm.	window showParagraph: strm contents asParagraph]\gb31Bshowstructure: window   "print my class name, superclass, fields, and properties"		| p properties strm	[strm_IndentingStream default.	strm append: 'Class '; append: self class title; indent.	[self classObject[]	 strm cr; append: 'Superclass'; indent; cr;		append: self class superclass title; unindent].	strm cr; append: 'Parts'; indent.	self printfieldstructure: strm.  strm unindent.	properties_self properties.	for p from: properties contents sort do		[propertiesp printproperty: strm].	window showParagraph: strm contents asParagraph]\gb24Bi57Ishowsubclasstemplate: window	[window showParagraph:		'NewClassName    ''fields - optional''' asParagraph]\gb30BThingLab Editing\f5bgconstrainers | paths	["return a vector of paths to attachers used when using me to 		constrain an existing part in an object being edited"	paths_self class classvars lookup: constrainers[paths]	self classObject[EmptyPath inVector]	self class superclass prototype constrainers]\gb13B11i115Iconstrainers: vec | paths i	[paths_Vector new: vec length.	for i to: vec length do		[pathsi _ (veci) asPath].	self class classvars insert: constrainers with: paths.	self forgetConstraintMethods]\gb18Bdelete: path  "delete the field at the end of path"		| merge difference p	["Check for any other paths to the field.  This needs to be done before		deleting the field indicated by path itself, since these merges will		otherwise be deleted"	for merge from: (self merges lookupVec: path firstName) do		[difference_path withinOneOf: merge paths.		differencefalse[]		for p from: merge paths do			[self deletePath: (p concat: difference)]].	self deletePath: path]	\gb14Bi32u4U1I27i163IdeletePath: path | firstName tail f	["Delete the field at the end of path (ignoring merges).		For use by delete: message"	firstName_path firstName.  tail_path tail.	f_self fieldProperty: firstName.	f type=spare["already deleted"]	tail empty		[self isPrototypefalse[user notify: 'I am not a prototype']		f type_spare.		self properties deleteFrom: self ifOverlaps: path.		self forgetConstraintMethods.		self field: firstName replaceWith: nil.  "should also check descendants"]	(self field: firstName) tryDeleting: tail owner: self name: firstName]\gb17B21i32u4U33u7U9I96i15I226i29IeditingToolsFor: format  "return a vector of classes of editing tools"	[format isPicture		[Inserter, Deleter, Constrainer, MergingMover, Mover, TextEditor]	Vector new: 0]\gb25B1i43Iframe | f  "return my frame if I can find it, otherwise make one up"	[f_self frameOrNil.	fnil[00 rect: 00]	f]\gb6B6i55IframeOrNil  "return my frame if I can find it, otherwise nil"		| f p pFrame	[for p from: self parts do		[pFrame_p frameOrNil.		pFramenil[]		fnil[f_pFrame]		f_f include: pFrame].	f]\gb12B1i47Igrow  "increase my instance size"	[user notify: 'not completed']\gb6B1i25Ihas: pt | p	[for p from: self parts do		[p has: pt[true]].	false]\gb8Bhitgap  "the allowable error in pointing at me with the mouse"	[10]\gb8B1i52Iinsert: x | f p  "insert new part x and return the path to it"	[self isPrototypefalse[user notify: 'I am not a prototype']	self forgetConstraintMethods.	"look for a spare field"	for f from: self fieldProperties do		[f type=spare			[f type_part.			self field: f name replaceWith: x.			p_f asPath.			x relocatePaths: p.			p]].	self grow.  self insert: x]\gb10B8i43I98i22Iinserters | paths	["return a vector of paths to attachers used when inserting me in 		another object"	paths_self class classvars lookup: inserters[paths]	self classObject[EmptyPath inVector]	self class superclass prototype inserters]\gb10B11i81Iinserters: vec | paths i	[paths_Vector new: vec length.	for i to: vec length do		[pathsi _ (veci) asPath].	self class classvars insert: inserters with: paths.	self forgetConstraintMethods]\gb15BinstancePaths: cl "return a vector of paths to instances of class cl or its subclasses"		| instancePathsDict partsDict paths f p prefix part 			subPart subPaths strm"First check if I'm an instance of cl.  If not, then check in my dictionary of instance paths to see if there is an entry for cl.  If that fails too, then find a path to each of my parts which is an instance of cl.  If there is more than one path to that part, put only one of them in the vector."	[self Is: cl[EmptyPath inVector]	instancePathsDict_self instancePathsDict.	paths_instancePathsDict lookup: cl[paths]	"avoid problem of multiple paths to a part by indexing by part"	partsDict_EqDictionary init.	for f from: self fieldProperties do		[f typepart			[subPaths_(self field: f pathName) instancePaths: cl.			prefix_f asPath.  part_self instfield: f index.			for p from: subPaths do				[subPart_p applyTo: part.				partsDict insert: subPart with: (prefix concat: p)]]].	strm_(Vector new: 10) asStream.	for subPart from: partsDict do		[strm next_partsDictsubPart].	paths_strm contents.	instancePathsDict insert: cl with: paths.	paths]\gb18B1i47u2U18I83i295I128i61IinstancePathsDict "return a dictionary of paths to my parts which are instances of some class.  This dictionary is indexed by class"		| dict	[dict_self class classvars lookup: instancePathsDict.	 [dictfalse[]  dictnil[]  dict].	dict_Dictionary init.	self class classvars insert: instancePathsDict with: dict.	dict]\gb18B1i112IinvertMessage: str	[self  'self invert' + str]\gb20Blocation [self frame center]\gb9BreceiveMessage: str	[self  ('self ' + str)]\gb21BrelocatePaths: prefix | f i	["Prefix all my relative reference paths with prefix, and ask 		my subparts to do so as well.  Since relatively few fields are		relocatable, it might be more efficient to compile a special message 		when an object has such fields."	for f from: self fieldProperties do		[f relocatePathFor: self prefix: prefix].	for i to: self class instsize do		[(self instfield: i) relocatePaths: prefix]]\gb22B9i44u6U181ItryDeleting: path owner: owner name: name	["The default is that I must be a prototype to do deleting.		If I am not a prototype, tell my owner to delete me."	self isPrototype[self delete: path]	owner delete: (AccessPath new names: name inVector)]\gb43B2i112IusefulClasses [Things contents sort]	\gb14BThingLab Recompiling Messages\f5bginterpret: keyword with: arg1 | message transform target	["make up a compile-time message, transform it, and send it"	message_Message new 		context: self		receiver: EmptyPath		constraint: nil owner: EmptyPath		keywords: keyword inVector		arguments: ('arg1')		uniqueState: true referenceOnly: false compileTimeOnly: false.	transform_self transform: message.	target_transform receiver applyTo: self.	target perform: transform selector with: arg1]\gb30B30i57Iinvertmoveby: pt [self interpret: 'moveby:' with: 00-pt]\gb17Binvertscaleby: s [self interpret: 'scaleby:' with: 1.0/s]\gb17Bmoveby: pt [self interpret: 'moveby:' with: pt]\gb11Bscaleby: s [self interpret: 'scaleby:' with: s]\gb11BThingLab Copying & Merging\f5bgchangeValue: t  	["Crock.  like copyFrom, but interpreted as making me semialterable 		rather than unalterable.  See Message sentNext:"	self copyFrom: t]\gb18B2i116IcopyFrom: other | i f    "recursively copy fields from other"	[f_self fieldProperties.	for i to: f length do		[(fi) type=part			[(self instfield: i) copyFrom: (other instfield: i)];		 =primitive			[self instfield: i _ other instfield: i]]]\gb16B9i30u5U1IcopyFrom: other scaledBy: s | message transform	[self copyFrom: other.	message_Message new 		context: self		receiver: EmptyPath		constraint: nil owner: EmptyPath		keywords: ( 'scaleby:' )		arguments: ('delta')		uniqueState: true referenceOnly: false compileTimeOnly: false.	transform_self transform: message.	(transform receiver applyTo: self) perform: transform selector with: s]\gb28BmergeWith: other   "return the result of a destructive merge"		| i	[othernil[]	self classother class		[for i to: self class instsize do			[self instfield: i _ (self instfield: i) mergeWith: (other instfield: i)]]	user notify: 'classes not compatable for merging']\gb19Bi42Irecopy   "return a complete topological copy of myself"	[self classObject[self]	self merges empty[self class recopy: self]	self recopy: EqDictionary init]\gb9Bi46Irecopy: dict   "return a complete topological copy of myself.  dict is an EqDictionary, consisting on the left hand side of original objects, and on the right of copies."		| copy i	[self classObject[self]	(copy_dict lookup: self)[copy]	copy_self class new.	dict insert: self with: copy.	for i to: self class instsize do		[copy instfield: i _ (self instfield: i) recopy: dict].	copy]\gb15Bi155IshouldMergeWith: other	[other location has: self location]\gb24BThingLab Filin and Filout\f5bgcanFiloutContents	["return true if the contentsCodeTo: message can be used to print all of my state"	false]\gb19B2i79IconstraintCodeTo: printer | strm	["not yet automatic - currently the user must write a 		addConstraints message if constraints are present"	self constraints empty[]	self class canunderstand: addConstraints		[strm_Stream default.		strm append: self class title; append: ' prototype addConstraints.'.		printer print: strm contents asParagraph]	user notify: 'I have constraints but no addConstraints message']\gb26B10i104IcontentsCodeTo: strm	["Add code to strm to make an instance like me"	self printon: strm]\gb22B2i44IcontentsCodeTo: strm prefix: prefix | f	["add code to strm to change the contents of a new instance of my class		 to be my contents"	for f from: self fieldProperties do		[f contentsCodeTo: strm prefix: prefix for: self]]\gb36B7i90IcontentsCodeTo: printer prefix: prefix owner: owner | f strm	["add code to change the contents of a new instance of my class		to be my contents.  If I can print simply then do so; 		otherwise recursively filout my parts"	self canFiloutContents		[strm_Stream default.		prefix codeTo: strm context: owner class title+' prototype'.		strm append: ' copyFrom: ('.		self contentsCodeTo: strm.		strm append: ').'.		printer print: strm contents asParagraph]	for f from: self fieldProperties do		[f contentsCodeTo: printer prefix: prefix owner: owner]]\gb52B12i158IfieldInitCodeTo: printer  "Add code that initializes my fields"		| f	[for f from: self fieldProperties do		[f initCodeTo: printer for: self]]	\gb26B1i35IfieldPropertyCodeTo: printer  "Add code that classifies my fields"		| strm parts primitives unnamedParts spares f n	[strm_Stream default.	parts_HashSet init.  primitives_HashSet init.	unnamedParts_HashSet init.  spares_HashSet init.	for f from: self fieldProperties do		[n_f name.		f typepart[f named[parts insert: n] unnamedParts insert: n]		f typeprimitive[primitives insert: n]		f typespare[spares insert: n]		user notify: 'unknown field type'].	strm append: self class title; append: ' prototype parts: '''.	for n from: parts contents sort do [strm append: n; space].	strm append: '''; primitives: '''.	for n from: primitives contents sort do [strm append: n; space].	strm append: '''; unnamedParts: '''.	for n from: unnamedParts contents sort do [strm append: n; space].	strm append: '''; spares: '''.	for n from: spares contents sort do [strm append: n; space].	strm append: '''.'.	printer print: strm contents asParagraph]	\gb30B1i34Ifilin: name | f	[user displayoffwhile		[f_dp0 file: name.		f end[user notify: 'no data']		self readPara: f contents asParagraph fromBravo.		f close]]\gb12BfiloutPreferred  "compatability crock - file out in preferred format"	[self sourceCode text='no source code'		[self filoutPrototype]	self filoutSourceCode]\gb17B1i50IfiloutPrototype  | printer	["file out my class, adding statements to re-create my prototype"	user displayoffwhile		[printer_(dp0 file: self class title+'.st.') asParagraphPrinter.		printer stamp; printclass: self class.		self fieldPropertyCodeTo: printer;			fieldInitCodeTo: printer;			contentsCodeTo: printer prefix: EmptyPath owner: self;			constraintCodeTo: printer;			mergeCodeTo: printer.		printer close.  self class noChanges]]\gb17B13i62IfiloutSourceCode | codePara f	[user displayoffwhile		[codePara_self sourceCode.		codePara text='no source code'[user notify: 'no source code']		f_dp0 file: self class title + '.st.'.		f append: codePara toBravo.		f shorten; close]]\gb17BmergeCodeTo: printer| m vec	["find all my merges"	vec_self merges allentries.	vec length=0[]	"add code to re-generate them"	for m from: vec do		[m mergeCodeTo: printer for: self]]\gb20B11i18I50i28IprimitiveCodeTo: strm	["I am a primitive of some sort.  Add code to strm to make an		instance like me"	self printon: strm]\gb23B2i78IreadPara: p  "read in a new Thinglab class (not necessarily my own)"		| para strm name class	[para_p asParagraph.	strm_para asStream.	"read in class definition -  must end with  "	class_nil (strm upto: 30).  "30 =  "	name_class title unique.	class_Smalltalkname.  "make sure its the real class"	SystemOrganization classify: name under: 'Prototype Classes'.	"CAREFUL!  initialize message dict and class vars"	class classvars init.  class md close.	class prototype sourceCode_para.	"read remainder of paragraph"	until strm end do [nil (strm upto: 30)]]\gb13B1i53I72i44I33i7I53i28I67i48I78i27IsourceCode | para	[para_self class classvars lookup: sourceCode.	nilpara or falsepara['no source code' copy asParagraph] 	para]\gb11BsourceCode_para	[self class classvars insert: sourceCode with: para asParagraph]\gb17BThingLab / FPI\f5bgboxcomp [self frame boxcomp]\gb8Bclose []\gb6Bdisplayat: pt effect: effect clippedBy: clipRect | i	[for i to: self class instsize do		[(self instfield: i) displayat: pt effect: effect clippedBy: clipRect]]\gb49Bedit: superimage [self frame flash]\gb17Bextent [self frame extent]\gb7Borigin [self frame origin]\gb7Brectangle [self frame]\gb10Btranslate: pt [self moveby: pt]\gb14Btranslateto: pt [self moveby: pt-self frame origin]\gb16Bwhite [self frame clear: white]\gb6B\g