'From Smalltalk 5.4hXM on 23 July 1979 at 4:03:04 pm.'\g"AccessPath"l15000z20000\f5bgClass new title: 'AccessPath'	subclassof: Object	fields: 'names'	declare: 'fieldProperties merges ';	asFollows\f5bgA path is a way to get to one object from another by following a vector of field names.\igAccess to parts\f5bgnames [names]\gb6Bnames: names\gbTests\f5bg= other [names=other names]\gb8Bempty [names length=0]\gb6Boverlaps: other | i othernames	["Return true if my image is within other's image or		other's image is within my image."	othernames_other names.	for i to: (names length min: othernames length) do		[(namesi)=(othernamesi)[]  false].	true]\gb16B17i35u5U14u5U29IoverlapsOneOf: vec | p	["Return true if my image overlaps one of the paths in vec"	for p from: vec do 		[self overlaps: p[true]].	false]\gb19B6i54u3U1Iwithin: other | i length othernames otherlength	["Return the difference if my image is within other's image,		i.e. if my names is an extension of other's names."	othernames_other names.	length_names length.  otherlength_othernames length.	otherlength>length[false]	for i to: otherlength do		[(namesi)=(othernamesi)[]  false].	AccessPath new names: (names(otherlength+1 to: length)) copy]\gb14B36i45u5U48u5U10IwithinOneOf: vec | p difference	["Return true if my image is within one of the paths in vec"	for p from: vec do 		[difference_self within: p[difference]].	false]\gb17B17i55u3U1IOperations\f5bg- other	[self within: other		[AccessPath new names: 			(names(other names length+1 to: names length)) copy]	false]\gb9Badd: pName	[AccessPath new names: names, pName]\gb12BallButLast   "return a new path with all but the last name"		| newnames i	[newnames_Vector new: names length-1.	for i to: newnames length do [newnamesi _ namesi].	AccessPath new names: newnames]\gb13Bi46IapplyTo: object   "return the image of the object through me"		| image pName	[image_object.	for pName from: names do		[image_image field: pName].	 image]\gb18Bi43Iconcat: other	[AccessPath new names: (names concat: other names)]\gb15BfirstName [names1]\gb10BglobalRef| x	[self empty[nil]	x_Smalltalk(names1).	[x is: Class[x_x prototype]].	self tail applyTo: x]\gb9Bhash | x pName	[x_0.	for pName from: names do		[x_x lxor: pName hash].	x]\gb5BrelativeRef	[self applyTo: thisContext firstTopLevelOwner]\gb13Btail   "return a new path with all but the first name"		| newnames i	[newnames_Vector new: names length-1.	for i to: newnames length do [newnamesi _ names(i+1)].	AccessPath new names: newnames]\gb7Bi47ICompiling Methods\f5bgappendNamesTo: strm | pName	["append names with no spaces in between.		Put 'part' before integer names"	for pName from: names do		[[pName is: Integer[strm append: 'part']].		pName printon: strm]]\gb20B10i77IcodeTo: strm [self codeTo: strm context: 'self']\gb13BcodeTo: strm context: context| pName	["first put in necessary parens"	for pName from: names do [pName is: Integer[strm append: '(']].	strm append: context; space.	for pName from: names do		[pName is: Integer			[strm append: 'field: '; print: pName; append: ') ']		strm append: pName; space]]\gb29B10i31IPrinting\f5bgprintNamesOn: strm | pName	[for pName from: names do [strm print: pName; space]]\gb19Bprinton: strm	[strm append: '<'.	self printNamesOn: strm.	strm append: '>']\gb15Bprinttableoffields: strm | name	[self empty[strm append: 'empty']	for name from: names do [strm print: name; space]]\gb25BclassInit\f5bgclassInit	[Smalltalk declare: EmptyPath as: () asPath]\gb11BConversions\f5bgasPath\gb\gSystemOrganization classify: AccessPath under: 'ThingLab Constraints'.\gAccessPath classInit\g"Constraint"l15000z20000\f5bgClass new title: 'Constraint'	subclassof: Property	fields: 'rule  "a descriptive string"		messages   "Vector of messages that this constraint			continuously sends"		methods  "vector of methods for use by messages, or nil" 		error   "method that returns the error in satisfying				this constraint"		test   "method that returns whether or not this constraint				is satisfied"'	declare: '';	asFollows\f5bgThis class has not yet been commented\igInitialization\f5bgmessagesFromStrings: vec   "initialize methods and messages"		 | i strm n keywords oldkeywords m	[messages_Vector new: vec length.  methods_Vector new: vec length.	for i to: vec length do		[m_Message new fromString: veci.		"make a name for this method"		strm_Stream default.  strm append: name.		for n from: m receiver names do [strm append: n].		keywords_strm contents inVector.		"plug keywords into message"		oldkeywords_m keywords.		m keywords_keywords; arguments_(Vector new: 0).		messagesi_m.		"If message isn't compile time only, make a matching method"		m compileTimeOnly[]		oldkeywords=('alter')			["method not known - use relaxation"			methodsi_Relaxer new methodFor: m constraint: self]		methodsi_Method new keywords: keywords			arguments: (Vector new: 0) temps: (Vector new: 0) body: veci]]\gb27Bi33I171i29I135i27I97i59I55i33ImessagesNotUniqueState | m	[for m from: messages do		[m uniqueState_false]]\gb23Bmessages_vec   "vec may be either strings or instances of message"	[vec1 is: String[self messagesFromStrings: vec]	messages_vec]\gb15Bi51Imethods_methods\gbruleTestError: rule type: type  "automatically generate test and error""type is a kludge - constraint should deduce this"	[	 [type=Number		[test_Method new fromString:  '(' + (rule subst:'-' for: '=') +			') abs < self tolerance'.		 error_Method new fromString:  '(' + (rule subst:'-' for: '=') +			') asFloat']	 type=Point		[test_Method new fromString:  '(' + (rule subst:'-' for: '=') +			') abs < self tolerance asPoint'.		 error_Method new fromString:  '(' + (rule subst:'-' for: '=') +			')']	 test_Method new fromString: '' + rule.	 "no error expression"].	test keywords_(name+'Test') inVector.	errornil[]	error keywords_(name+'Error') inVector]\gb32B1i37I3i48I442i19Irule_rule\gbAccess to parts\f5bgerror [error]\gb6Berror_error  "also generate a default test"		| keyword	[[error is: String[error_Method new fromString: error]].	keyword_name+'Error'.	error keywords_keyword inVector.	test_Method new fromString: 'self ' + keyword + ' abs < self tolerance'.	test keywords_(name+'Test') inVector]\gb13Bmessages [messages]\gb9Bmethods [methods]\gb8Bname_name\gbrule [rule]\gb5Btest [test]\gb5Btest_test	[[test is: String[test_Method new fromString: test]].	test keywords_(name+'Test') inVector]\gb11BTests\f5bghasPath: path | message	[for message from: messages do		[path=message receiver[true]]	false]\gb14Boverlaps: path   "return true if any of my messages' receivers overlap path"		| message	[for message from: messages do		[message receiver overlaps: path[true]]	false]\gb17Bi54u4U1ICompiling\f5bgaddMessages: queue context: context owner: owner receiver: receiver		| message copy	["add my messages to the queue"	(self overlaps: receiver)false []	"see if I have already been told to add messages to the queue"	queue hasConstraint: self owner: owner[]	for message from: messages do		[message referenceOnly[]		"make a copy of my message with the correct context, receiver,			and owner"		copy _ Message new			context: context receiver: (owner concat: message receiver)			constraint: self owner: owner			keywords: message keywords arguments: message arguments			uniqueState: message uniqueState			referenceOnly: message referenceOnly			compileTimeOnly: message compileTimeOnly.		queue insert: copy.		copy addMessages: queue]]\gb70B17i30I39i62I107i76IcategoryName ['Constraints']\gb13BdeleteFrom: prototype | method	[super deleteFrom: prototype.	prototype forgetConstraintMethods.	for method from: methods do		[nilmethod[]  method uncompileIn: prototype].	self unindexIn: prototype.	test uncompileIn: prototype.	errornil[]	error uncompileIn: prototype]\gb22BindexIn: prototype | message	[for message from: messages do		[prototype constraints insert: message receiver firstName entry: self]]\gb19BinsertIn: prototype | method	[super insertIn: prototype.	prototype forgetConstraintMethods.	for method from: methods do		[nilmethod[]  method compileIn: prototype].	self indexIn: prototype.	[testnil[] test compileIn: prototype].	[errornil[] error compileIn: prototype]]\gb20BunindexIn: prototype | message	[for message from: messages do		[prototype constraints delete: message receiver firstName entry: self]]\gb21BShowing\f5bgprinton: strm	[strm append: 'Constraint ['; append: rule; append: ']' ]\gb15Bprintproperty: strm	[strm cr.  self printNameOn: strm.	strm append: ': ['; append: rule; append: ']']\gb21B\gSystemOrganization classify: Constraint under: 'ThingLab Constraints'.\g"MergeConstraint"l15000z20000\f5bgClass new title: 'MergeConstraint'	subclassof: Property	fields: 'paths'	declare: '';	asFollows\f5bgA merge constraint means that the merged objects are really the same - not just equal.  'name' is nil.\igAccess to parts\f5bgname ['merge']\gb5Bpaths [paths]\gb6Bpaths _ vec | i	[paths_Vector new: vec length.	for i to: vec length do		[pathsi _ (veci) asPath]]\gb12BHashing and Tests\f5bghasPath: path | message	[paths has: path]\gb14Boverlaps: path   "return true if any of my paths overlap path"		| p	[for p from: paths do		[p overlaps: path[true]]	false]\gb17Bi40u4U1ICompiling\f5bgaddMessages: queue context: context owner: owner receiver: receiver		| extension p message fullPaths i	[(self overlaps: receiver)false []	"see if the receiver is an extension of one of my paths.  If so, make		up a MergeMessage for the extensions only, to prevent waking up		constraints unnecessarily"	extension_false.	for p from: paths do		[extensionfalse[extension_receiver within: p]].	[extensionfalse[extension_EmptyPath]].	"compute the full paths from the context"	fullPaths_Vector new: paths length.	for i to: paths length do		[fullPathsi_(owner concat: pathsi) concat: extension].	message _ MergeMessage new			context: context paths: fullPaths constraint: self owner: owner.	queue hasMerge: message[]	queue addMerge: message.	message addMessages: queue]\gb70B74i162I140i39IcategoryClass  "return the class to use in making a category for me"	[MergeTable]\gb15B1i51IcategoryName ['Merges']\gb13BdeleteFrom: prototype	[super deleteFrom: prototype.	prototype forgetConstraintMethods.	self unindexIn: prototype; unmergePartsFor: prototype]\gb23BindexIn: prototype | path	[for path from: paths do		[prototype merges insert: path firstName entry: self]]\gb19BinsertIn: prototype	[super insertIn: prototype.	prototype forgetConstraintMethods.	self indexIn: prototype; mergePartsFor: prototype]\gb21BmergePartsFor: owner | newPart i	["Replace all the old objects with the one at the end of the first path.		This assumes that I have been indexed in owner's merge table"	newPart_paths1 applyTo: owner.	for i to: paths length do		[newPart_newPart mergeWith: (pathsi applyTo: owner)].	owner replace: paths1 with: newPart]\gb21B14i134IunindexIn: prototype | path	[for path from: paths do		[prototype merges delete: path firstName entry: self]]\gb21BunmergePartsFor: owner | p mergedObject	["This method assumes that all the merged parts were of the same class,		and that I am not indexed in owner's merge table"	mergedObject_paths1 applyTo: owner.	for p from: paths do		[owner replace: p with: mergedObject recopy]]\gb23B19i122IShowing\f5bgprinton: strm | path n	[for path from: paths do		[for n from: path names do 			[[n is: Integer[strm append: 'part']].			n printon: strm.  strm space].		strm append: ' '].	strm skip: 2]\gb14Bprintproperty: strm	[strm cr; print: self]\gb21BFilout\f5bgmergeCodeTo: strm | i n	[strm append: 'self merge: '.	for i to: paths length do		[strm append: ''''.		for n from: (pathsi) names do			[strm print: n; space].		strm append: ''''.		i<paths length[strm append: ', ']].	strm append: '.'; cr]\gb18BmergeCodeTo: printer for: owner | strm i n	[strm_Stream default.	strm append: owner class title; append: ' prototype merge: '.	for i to: paths length do		[strm append: ''''.		for n from: (pathsi) names do			[strm print: n; space].		strm append: ''''.		i<paths length[strm append: ', ']].	strm append: '.'.	printer print: strm contents asParagraph]\gb32B\gSystemOrganization classify: MergeConstraint under: 'ThingLab Constraints'.\g"MergeMessage"l15000z20000\f5bgClass new title: 'MergeMessage'	subclassof: Object	fields: 'context  "object in which method will be compiled"		paths  "paths to merged objects"		constraint  "pointer to the constraint which sends me"		owner  "path from context to owner of the constraint" '	declare: '';	asFollows\f5bguncommented \igAccess to parts\f5bgconstraint [constraint]\gb11Bcontext [context]\gb8Bcontext: context paths: paths constraint: constraint owner: owner\gbowner [owner]\gb6Bpaths [paths]\gb6BCompiling Methods\f5bgaddMessages: queue		| receiver c prefixPath suffixPath object pName	["If any of my paths were edited, find all the constraints which		might no longer be satisfied.  Add the messages from such		constraints to the queue."	for receiver from: paths do		[object_context.  prefixPath_EmptyPath.  suffixPath_receiver.		until suffixPath empty do			[pName_suffixPath firstName.			for c from: (object constraints lookupVec: pName) do				[c addMessages: queue context: context owner: prefixPath					receiver: suffixPath].			for c from: (object merges lookupVec: pName) do				[c addMessages: queue context: context owner: prefixPath					receiver: suffixPath].			object_object field: pName.			prefixPath_prefixPath add: pName.			suffixPath_suffixPath tail]]]	\gb21B50i152IPrinting\f5bgprinton: strm	[strm append: 'Message for '; print: paths;		append: ' by '; print: constraint]\gb15B\gSystemOrganization classify: MergeMessage under: 'ThingLab Constraints'.\g"MergeSet"l15000z20000\f5bgClass new title: 'MergeSet'	subclassof: Stream	fields: ''	declare: '';	asFollows\f5bgMerge sets hold a set of merge messages.\igAs yet unclassified\f5bgaddPathsTo: path set: set | i paths p suffixPath	["add to set all paths to the object indicated by path"	set has: path[]	set insert: path.	for i to: position do		[paths_(arrayi) paths.		suffixPath_path withinOneOf: paths			["add the suffixPath to each merge path, and add to the set"			for p from: paths do				[self addPathsTo: (p concat: suffixPath) set: set]]]]\gb26B25i8u3U38u4U3I129i59IallPathsTo: path   "return a vector of all paths to the object indicated by path"		| set	[set_HashSet init.	self addPathsTo: path set: set.	set contents]\gb19Bi57u4U1Idelete: message | i j	[i_1.	until (i>position or (arrayi)=message) do [i_i+1].	i>position[]	position_position-1.	for j from: i to: position do [arrayj_array(j+1)]]\gb16BhasMerge: merge		| i m	[for i to: position do		[m_arrayi.		(merge constraint=m constraint and merge owner=m owner)			and merge paths=m paths[true]].	false]\gb18Binit [self of: (Vector new: 20)]\gb5Binsert: message [self next_message]\gb16Bprinton: strm | i	[strm append: 'MergeSet'.	 for i to: (position min: 10) do		[strm cr; tab; print: arrayi].	position>10[strm cr; tab; append: '...']]\gb14B\gSystemOrganization classify: MergeSet under: 'ThingLab Constraints'.\g"Message"l15000z20000\f5bgClass new title: 'Message'	subclassof: Object	fields: 'context  "object in which method will be compiled"		receiver  "path from context to ultimate receiver"		constraint  "pointer to the constraint which sends me, or nil"		owner  "path from context to owner of the constraint, or 			EmptyPath if constraint is nil.			If not nil, message is actually sent to the owner"		keywords  "vector of keywords for message (strings)"		arguments  "vector of arguments for message (strings)"		uniqueState  "true iff only one state of my receiver			will satisfy my constraint"		referenceOnly  "true iff my receiver is only referenced"		compileTimeOnly '	declare: 'fieldProperties ';	asFollows\f5bgI describe a Smalltalk message that might be sent at run-time.  In the ThingLab report, I am called Class MessagePlan (a better name).\igAccess to parts\f5bgarguments [arguments]\gb10Barguments_arguments\gbcompileTimeOnly [compileTimeOnly]\gb16BcompileTimeOnly_compileTimeOnly\gbconstraint [constraint]\gb11Bcontext [context]\gb8Bcontext: context receiver: receiver constraint: constraint owner: owner	keywords: keywords arguments: arguments uniqueState: uniqueState	referenceOnly: referenceOnly compileTimeOnly: compileTimeOnly\gbcontext_context\gbfromString: s   "handles some simple cases"		| strm token path a	[strm_s asVector asStream.  path_(Vector new: 10) asStream.	token_strm next.	while ((token is: UniqueString) and (token numArgs=0)) do		[path next_token.  token_strm next].	tokenfalse		[token_path pop.  receiver_path contents asPath.		keywords_(''+token) inVector.  arguments_Vector new: 0.		token=reference[uniqueState_false.  referenceOnly_true.						compileTimeOnly_true];			=check[uniqueState_false.  referenceOnly_true.						compileTimeOnly_true];			=alter[uniqueState_false.  referenceOnly_false.						compileTimeOnly_false];			=fixed[uniqueState_true.  referenceOnly_false.						compileTimeOnly_true].		user notify: 'unknown keyword']	(token isnt: UniqueString) or (token numArgs1)		[user notify: 'string not of proper form'].	receiver_path contents asPath.	owner_EmptyPath.	keywords_(''+token) inVector.	token_strm next. a_Stream default.	while token do		[a print: token; space.  token_strm next].	arguments_a contents inVector.	uniqueState_true.  referenceOnly_compileTimeOnly_false]\gb16Bi27Ikeywords [keywords]\gb9Bkeywords_keywords\gbowner [owner]\gb6Breceiver [receiver]\gb9Breceiver_receiver\gbreceivingObject [receiver applyTo: context]\gb16BreferenceOnly [referenceOnly]\gb14BreferenceOnly_referenceOnly\gbuniqueState [uniqueState]\gb12BuniqueState_uniqueState\gbHashing and Tests\f5bg= m	["for looking up methods in method dictionaries and building message queues"	(receiver=m receiver and keywords=m keywords)		and (owner=m owner and constraint=m constraint)]\gb5B1i75Ihash | x s	[x_(receiver hash lxor: owner hash) lxor: constraint hash.	for s from: keywords do [x_x lxor: s hash].	x]\gb5BsameAs: message receiverPaths: receiverPaths	["return true if I am the same as message.  ReceiverPaths is a vector		of all paths to its receiver"	(message owner=owner)false[false]	(message constraint=constraint)false[false]	(message keywords=keywords)false[false]	(message arguments=arguments)false[false]	receiverPaths has: receiver[true]	false] \gb46B2i32u7U3u13U43ICompiling Methods\f5bgaddMessages: queue		| c prefixPath suffixPath object pName	["If my receiver were edited, find all the constraints which might no		longer be satisfied.  Add the messages from such constraints		to the queue."	object_context.  prefixPath_EmptyPath.  suffixPath_receiver.	until suffixPath empty do		[pName_suffixPath firstName.		for c from: (object constraints lookupVec: pName) do			[c addMessages: queue context: context owner: prefixPath				receiver: suffixPath].		for c from: (object merges lookupVec: pName) do			[c addMessages: queue context: context owner: prefixPath				receiver: suffixPath].		object_object field: pName.		prefixPath_prefixPath add: pName.		suffixPath_suffixPath tail]]	\gb21B41i148IcanBePostponed: queue | m	["return true if I can be sent last.  To be sent last, neither my receiver		nor any of its parts can be unalterable.  Also, either I must be the		only message to my receiver, or all messages to my receiver must		come from the same constraint and owner."	queue testForUnalterablePart: receiver[false]	for m from: (queue findReceiver: receiver) do		[selfm[]		constraintnil[false]		constraint=m constraint and owner=m owner[]		false].	true]\gb22B6i255IcanBeSentNext: queue  "return true if I can be sent next"		| path message	["The following conditions must be true for me to be sent next:		my constraint uniquely determines the state of my receiver;		my receiver or one of its parts isn't already unalterable;		and all the objects that I reference are unalterable.		Or: (kludge) If I am sent by a SetMembershipConstraint."	constraint is: SetMembershipConstraint[true]	uniqueStatefalse[false]	queue testForUnalterablePart: receiver[false]	constraintnil[true]	"If any of the objects that I reference may still change, return false"	for message from: constraint messages do		[path_owner concat: message receiver.		path=receiver["it's the one I alter"]		queue testIfUnalterable: path[]		"last chance!  If this message is reference only, and there are 			no altering messages to it in the queue, it won't change."		message referenceOnly and (queue noAlteringMessagesTo: path)[]		false].	"Kludge!  If I am sent by a set constraint, check actual messages in queue"	[constraint is: SetConstraint		[for message from: (queue findConstraint: constraint owner: owner) do			[messageself[]			queue testIfUnalterable: message receiver[]			false]]].	true]\gb22Bi35bI3B17i299I152i70I104i20I41i124I81i74Ichecked: queue | m	["Delete myself from the queue.  Since I will check my constraint,		none of the other messages from my constraint need to be sent."	constraintnil[queue delete: self]	for m from: (queue findConstraint: constraint owner: owner) do		[queue delete: m]]\gb15B6i130IchecksTo: strm | i	[owner codeTo: strm.	strm append: constraint test selector; 		append: 'false[user cr; show: ''';		append: constraint name;		append: ' constraint not satisfied'']'; cr]\gb15BcodeTo: strm | i	[[compileTimeOnly[strm append: ' "dummy message: ']].	([nilconstraint[receiver] owner]) codeTo: strm.	[arguments length=0[strm append: keywords1]	for i to: keywords length do		[strm append: keywordsi; space; append: argumentsi; space]].	strm append: '.' .	[compileTimeOnly[strm append: ' " ']].	strm cr]\gb13B3b2BmakeMethod   "return the skeleton of a method for editing my receiver"		| method strm newkeywords	[method_Method new.	"make new keywords"	strm_Stream default.	receiver appendNamesTo: strm.  strm append: keywords1.	newkeywords_keywords copy.  newkeywords1_strm contents.	method keywords_newkeywords.	method arguments_arguments.  method temps_Vector new: 0.	method body_''.	method]\gb13Bi57I51i19InoBackPointerCopy  "return a copy of me without backpointers"	[Message new context: nil receiver: receiver		constraint: nil owner: EmptyPath		keywords: keywords arguments: arguments		uniqueState: uniqueState referenceOnly: referenceOnly		compileTimeOnly: compileTimeOnly]\gb19B1i40Ipostponed: queue | m	["Delete myself from the queue.  Since I have been postponed,		none of the other messages from my constraint need to be sent.		Nothing needs to be done with unalterable or semialterable,		since the receiver of this message doesnt affect anyone else		(I hope ...) "	constraintnil[queue delete: self]	for m from: (queue findConstraint: constraint owner: owner) do		[queue delete: m]]\gb17B6i266Iselector | strm k	[strm_Stream default.	for k from: keywords do		[strm append: k].	strm contents unique]\gb9BsentNext: queue | m	["Delete myself from the queue.  Since I have been sent,		none of the other messages from my constraint need to be sent.		If my constraint must be satisfied,		then add my receiver to unalterable.  Otherwise, discourage 		alteration of my receiver.  KLUDGE - this is currently done by seeing 		if the keyword is moveby: .  Eventaully, the constraints should 		indicate this.  Some possible classifications are: 			must be satisfied			satisfy if possible (but not an error if not satisfied - e.g., moveby:)			minimize sum of squares of errors ( as in bridges) "	[constraintnil[queue delete: self]	 for m from: (queue findConstraint: constraint owner: owner) do		[queue delete: m]].	"eventually, in making my receiver unalterable or semialterable,		the queue should check if several unalterable subparts can be		combined into a larger unalterable part.		KLUDGE! decide whether receiver is unalterable or semialterable based on		keywords.  Eventually, this should be specified by an instance variable."	keywords=('moveby:') or keywords=('changeValue:')		[queue makeSemialterable: receiver]	queue makeUnalterable: receiver]\gb16B6i185u11U119u7U181u7U56I131i320IshouldBePostponed: queue	["return true if I should be sent last.  I should be sent last if I can be		sent last, and if my receiver or one of its parts isn't semialterable"	queue testForSemialterablePart: receiver[false]	self canBePostponed: queue]\gb26B1i67u3U76IPrinting\f5bgprinton: strm	[strm append: 'Message for '; print: receiver;		append: ' by '; print: constraint]\gb15B\gSystemOrganization classify: Message under: 'ThingLab Constraints'.\g"MessageQueue"l15000z20000\f5bgClass new title: 'MessageQueue'	subclassof: Stream	fields: 'merges  "a MergeSet"		unalterable  "vector of paths to objects which cannot be altered"		semialterable  "vector of paths to objects which should not be altered 			unless necessary"		temps  "stream of names of temporaries" '	declare: '';	asFollows\f5bgMessageQueues hold a queue of messages waiting to be processed when compiling constraint satisfaction methods.\igAccess to parts\f5bglength  "return length of the queue"	[position]\gb8B1i26Imerges [merges]\gb7Bsemialterable [semialterable]\gb14Btemps [temps]\gb6Bunalterable [unalterable]\gb12Bunalterable_unalterable\gbInitialization\f5bginit	[self of: (Vector new: 20).	merges_MergeSet init.	unalterable_Vector new: 0.	semialterable_Vector new: 0.	temps_(Vector new: 10) asStream]\gb6BSearching\f5bgfindConstraint: constraint owner: owner   "return a vector of messages"		| strm i message paths	["return a vector of all messages from the constraint"	strm_(Vector new: 10) asStream.	"check all paths to the constraint"	paths_merges allPathsTo: owner.	for i to: position do		[message_arrayi.		constraint=message constraint			[paths has: message owner[strm next_message]]].	strm contents]\gb42Bi29I28i53I35i35IfindEqualMessages: message  "return a vector of messages equal to message"		| i m keywords paths owner constraint strm	[strm_(Vector new: 10) asStream.	paths_merges allPathsTo: message receiver.	owner_message owner.	constraint_message constraint.	keywords_message keywords.	for i to: position do		[m_arrayi.		(m owner=owner)false[]		(m constraint=constraint)false[]		(m keywords=keywords)false[]		paths has: m receiver[strm next_m]].	strm contents]\gb28B1i37u7IUfindPostponable  "return a postponable message"		| i	[for i to: position do		[arrayi shouldBePostponed: self[arrayi]].	for i to: position do		[arrayi canBePostponed: self[arrayi]].	 false]\gb17Bi30IfindReceiver: receiver   "return a vector of all messages affecting receiver"		| paths strm i	[paths_merges allPathsTo: receiver.	strm_(Vector new: 10) asStream.	for i to: position do		[(arrayi) receiver overlapsOneOf: paths[strm next_arrayi]].	strm contents]\gb25Bi43u8U1IfindSendable  "return a message that can be sent next"		| i	[for i to: position do		[arrayi canBeSentNext: self[arrayi]].	 false]\gb14Bi40IhasConstraint: constraint owner: owner		| i message paths	[paths_merges allPathsTo: owner.	for i to: position do		[message_arrayi.		constraint=message constraint[paths has: message owner[true]]].	false]\gb41BhasMerge: merge	[merges hasMerge: merge]\gb17BnConstraintsOn: receiver   "return the number of constraints on receiver"		| paths nConstraints i	[paths_merges allPathsTo: receiver.	nConstraints_0.	for i to: position do		[(arrayi) referenceOnly["doesn't count"]		(arrayi) receiver overlapsOneOf: paths			[nConstraints_nConstraints+1]].	nConstraints]\gb27Bi37u8U1I134i13InoAlteringMessagesTo: receiver | vec m	[vec_self findReceiver: receiver.	for m from: vec do		[m referenceOnlyfalse[false]].	true]\gb31BpickUnknown | receiver i bestYet isSemiAlterable nConstraints n	["Return a path to an unknown.  Try not to alter stuff in		semialterable.  Also look for the receiver with the most constraints.		See Sussman and Stallman."	bestYet_false.  isSemiAlterable_true.  nConstraints_0.	for i to: position do		[receiver_(arrayi) receiver.		self testForUnalterablePart: receiver["reject"]		self testForSemialterablePart: receiver			[isSemiAlterablefalse["reject-worse than bestYet"]			n_self nConstraintsOn: receiver.			n>nConstraints				[bestYet_receiver.				nConstraints_n]]		n_self nConstraintsOn: receiver.		n>nConstraints			[bestYet_receiver.			nConstraints_n.			isSemiAlterable_false]].	bestYet]\gb12B54i156I157i6I74i25IInserting & Deleting\f5bgaddMerge: message [merges insert: message]\gb18Bdelete: message | i j	[i_1.	until (i>position or (arrayi)message) do [i_i+1].	i>position[]	position_position-1.	for j from: i to: position do [arrayj_array(j+1)]]\gb16BdeleteDuplicates  "delete duplicate messages"		| duplicates message paths i j	[duplicates_(Vector new: 10) asStream.	for i to: position do		[message_arrayi.		paths_merges allPathsTo: message receiver.		for j from: i+1 to: position do			[(arrayj) sameAs: message receiverPaths: paths				[duplicates next_arrayj]]].	for message from: duplicates contents do		[self delete: message]]\gb18B1i25Iinsert: message [self next_message]\gb16BAlterable Paths\f5bgmakeSemialterable: path | p	[for p from: (merges allPathsTo: path) do		[p withinOneOf: semialterable[]		semialterable_semialterable, p]]\gb24BmakeUnalterable: path | p	[for p from: (merges allPathsTo: path) do		[p withinOneOf: unalterable[]		unalterable_unalterable, p]]\gb22BtestForSemialterablePart: path	["return true if the object at the end of path or one of its parts		is semialterable"	path overlapsOneOf: semialterable]\gb32B2i83ItestForUnalterablePart: path	["return true if the object at the end of path or one of its parts		is unalterable"	path overlapsOneOf: unalterable]\gb30B2i81ItestIfSemialterable: path	[path withinOneOf: semialterable]\gb27BtestIfUnalterable: path	[path withinOneOf: unalterable]\gb25BPrinting\f5bgprinton: strm | i	[strm append: 'MessageQueue'.	 for i to: (position min: 10) do		[strm cr; tab; print: arrayi].	[position>10[strm cr; tab; append: '...']].	strm cr.  merges printon: strm]\gb14B\gSystemOrganization classify: MessageQueue under: 'ThingLab Constraints'.\g"Relaxer"l15000z20000\f5bgClass new title: 'Relaxer'	subclassof: Object	fields: 'context  "object which creates this relaxer"		objects   "a vector of objects being relaxed"		ownerVecs  "vector of vector of owners of constraints"		errorVecs  "vector of vector of selectors for constraint			error message"		testVecs  "vector of vector of selectors for constraint			satisfaction test message"		methods  "vector of selectors for methods to			be executed after each change to an object			in objects"		object owners errors tests method			"particular elements of above vectors under			consideration"		showImage  "true iff image should be updated after each cycle"		mem067   "for saving old display height" '	declare: '';	asFollows\f5bgThis is the relaxation method for solving simultaneous constraints.  Instances of this class are used both at compilation time and execution time.  At compilation time, all the instance variables above will be streams instead of vectors, and paths to objects rather than pointers will be used.During execution, an iteration consists of computing some new contents for each object to satisfy its constraints as well as possible, using the message solve.  In this version, the constraints are declared unsatisfiable if the sum of the squares of the errors changes by less than minChange after an iteration.  Relaxation stops when all the constraints are satisfied.  Ugh.\igCompiling\f5bgcheckNumArgs: x | y	[x is: Vector		[for y from: x do [self checkNumArgs: y]]	x mustTake: 0]\gb16BcircularMethod: context queue: queue		| unknown	["return code to invoke the relaxation method"	objects_(Vector new: 10) asStream.	ownerVecs_(Vector new: 10) asStream.	errorVecs_(Vector new: 10) asStream.	testVecs_(Vector new: 10) asStream.	methods_(Vector new: 10) asStream.	unknown_queue pickUnknown.	while unknown do		["find the largest container of the unknown that can be relaxed"		object_context largestRelaxablePart: unknown.		self propagate: queue.		unknown_queue pickUnknown].	self relaxationCode: queue]\gb39B12i45I238i61ImethodFor: message constraint: constraint | strm	["no method was given for satisfying the constraint (i.e.,		 message keyword was 'alter'.  Make a method that invokes relaxation.		Note that this message is used tup a relaxer for a single constraint - 		its use is different than the messages for relaxing in the event of circularity."	strm_Stream default.	strm append: ' relaxer_Relaxer new.'; cr;		append: 'relaxer context: self objects: '; 		print: message receiver names inVector; cr;		append: ' ownerVecs: (( () ))'; cr;		append: ' errorVecs: '; 		print: constraint error selector inVector inVector; cr;		append: ' testVecs: '; 		print: constraint test selector inVector inVector; cr;		append: ' methods: (none).'; cr;		append: 'relaxer relaxQuiet. '.	Method new keywords: message keywords		arguments: message arguments 		temps: ('relaxer') body: strm contents]\gb42B10i285IpickErrors: queue oldUnalterable: oldUnalterable		| picked path message m	["Find the vectors of owners, errors and tests.		Delete these messages from the queue.		Choose only one error and test per constraint"	picked_MessageQueue init.	owners_(Vector new: 10) asStream.	errors_(Vector new: 10) asStream.	tests_(Vector new: 10) asStream.	for path from: queue unalterable do		[oldUnalterable has: path[]		for message from: (queue findReceiver: path) do			[queue delete: message.			picked hasConstraint: message constraint owner: message owner[]			picked insert: message.			owners next_message owner.			errors next_message constraint error selector.			tests next_message constraint test selector.			"delete messages from this constraint to objects in oldUnalterable,				since the				errors for their constraint will be taken care of by the relaxer"			for m from: (queue findConstraint: message constraint 					owner: message owner) do				[oldUnalterable has: m receiver[queue delete: m]]]].	ownerVecs next_owners contents.	errorVecs next_errors contents.	testVecs next_tests contents]\gb51B26i135I507i52u14U85Ipropagate: queue		| propagated code name body oldUnalterable	[objects next_object.	"save old vector of unalterable paths"	oldUnalterable_queue unalterable.	queue makeUnalterable: object.	body_context workForwards: queue.	[body length=0[methods next_none]	 code_Stream default.  code append: 'relax'.	 object appendNamesTo: code.  code space.	 code append: ' ['; append: body; append: ']'.	 "compile this method, and save the selector"	 methods next_context class understands: code contents].	"pick errors to be considered"	self pickErrors: queue oldUnalterable: oldUnalterable.	"restore vector of unalterable paths"	queue unalterable_oldUnalterable]\gb19B68i36I280i44I60i30I59i35IrelaxationCode: queue		| code i j nObjects nConstraints objectPaths ownerPaths	[nObjects_objects position.	"If the number of objects to be relaxed is 0, then don't generate any code.		This may occur if there are constraints that need to be checked."	nObjects=0['']	user cr; show: 'WARNING - relaxation method being compiled in '		+ context class title.	queue temps append: ('relaxer').	objectPaths_Vector new: nObjects.  ownerPaths_Vector new: nObjects.	for i to: nObjects do		[objectPathsi_(objectsi) names.		nConstraints_(ownerVecsi) length.		ownerPathsi_Vector new: nConstraints.		for j to: nConstraints do			[ownerPathsij_(ownerVecsij) names]].	code_Stream default.	"check the number of args for selectors so that performDangerously		 can be used during execution"	self checkNumArgs: errorVecs contents; checkNumArgs: testVecs contents;		checkNumArgs: methods contents.	code append: ' relaxer_'; append: self class title; append: ' new.'; cr; cr;		append: 'relaxer context: self objects: '; print: objectPaths; cr; cr;		append: ' ownerVecs: '; print: ownerPaths; cr; cr;		append: ' errorVecs: '; print: errorVecs contents; cr; cr;		append: ' testVecs: '; print: testVecs contents; cr; cr;		append: ' methods: '; print: methods contents; append: '.'; cr; cr;		append: 'relaxer '; append: self relaxSelector; append: '. '.	code contents]\gb24B87i141I450i99IrelaxSelector	["return the selector to use when invoking me during execution -		should be either 'relax' or 'relaxQuiet' "	objects position=1['relaxQuiet']	'relax']\gb15B2i106IInitialization\f5bgcontext: context objects: objectPaths ownerVecs: ownerPaths	errorVecs: errorVecs testVecs: testVecs methods: methods		| i j 	["convert object paths into pointers"	objects_Vector new: objectPaths length.	for i to: objectPaths length do		[objectsi_(AccessPath new names: objectPathsi) applyTo: context].	"convert vectors of owner paths into vectors of owners"	ownerVecs_Vector new: ownerPaths length.	for i to: ownerPaths length do		[owners_ownerPathsi.  ownerVecsi_Vector new: owners length.		for j to: owners length do			[ownerVecsij_(AccessPath new names: ownersj) applyTo: context]].	showImage_true]\gb120B9i36I148i55IExecution\f5bgadd: change	[object add: change.	methodnone[]  context performDangerously: method]\gb13BcheckError: toterror old: old   "true if relaxation should stop"	["If the total error has increased, something is wrong."	toterror > old 		[user cr; show: 'error increased during relaxation!!!'.  true]	"If the total error has decreased by less than minChange,		the constraints aren't satisfiable."	(context minChange * toterror) > (old - toterror) abs 		[user cr; show: 'constraints not satisfied after relaxation'.  true]	false]\gb32Bi33I3i55I86i47u9U40IcheckKBD: toterror stop: stop   "maybe print error"		| flag   "true if the toterror should be printed"	[flag_stop.   "always print error when stopping"	"Check if the user typed e, q, s, or n.  Discard other characters.		Use rawkbck to prevent purging with each check."	while user rawkbck do		[user kbd=('e'1)[flag_true];			=('q'1)[flag_stop_true];			=('s'1)[showImage[]						showImage_true.  mem067_mem067.  mem067_nil];			=('n'1)[showImage								[showImage_false.  mem067_mem067.								mem067_58]]].	[flag[self printError: toterror]].	"if stop is true and the display was shortened, restore it"	[stop and (mem067nil)false[mem067_mem067]].	stop]\gb32Bi19I12i13u8U19I16i34I2i73u7U37I297i57Icycle | i   "relax each object"	[for i to: objects length do		[object_objectsi.  owners_ownerVecsi.  errors_errorVecsi.		method_methodsi.		object is: Point[self add: self solvePoint]		object is: Magnitude[self add: self solveMagnitude]		user notify: 'unknown class for relaxing']]\gb6B6i19ImakeIntoFloat | o	[for o from: objects do		[o makeIntoFloat]]\gb14BprintError: error	[user cr; show: 'error = '; show: error asString]\gb19BreducePointMatrix: m | new i j k sum	["reduce m to a 2 by 3 matrix"	new_Vector new: 2.	new1_Vector new: 3.  new2_Vector new: 3.	for i to: 2 do		[for j to: 3 do			[sum_0.0.			for k to: m length do				[sum_sum + ((mki)*(mkj))].			newij_sum]].	new]\gb21B19i7u1U19Irelax   "relax objects until constraints are satisfied"		|	stop   "true if relaxation should stop"			toterror   "the sum of the squares of the errors in the constraints"			old   "the toterror from the previous iteration"			window	[user cr; show: 'relaxing - type ''e'' to see error; ''q'' to quit;''s'' to show image; ''n'' to not show it'.	self makeIntoFloat.	stop _ false.  old _ 1.0e1000.	until stop do		[self cycle.   "relax each object"		  [stop_self testConstraints[]		  toterror _ self toterror.		  self checkError: toterror old: old[stop_true]		  old _ toterror].		stop_self checkKBD: toterror stop: stop.		showImage and (window_user topLabWindow)			[window showBuffered]].	self undoMakeIntoFloat]\gb8Bi47I12i32I15i57I10i5u8U29I211i19IrelaxQuiet   "like relax, but no display stuff"		|	stop   "true if relaxation should stop"			toterror   "the sum of the squares of the errors in the constraints"			old   "the toterror from the previous iteration"			window	[self makeIntoFloat.	stop _ false.  old _ 1.0e1000.	until stop do		[self cycle.   "relax each object"		stop_self testConstraints[]		toterror _ self toterror.		self checkError: toterror old: old[stop_true]		old _ toterror].	self undoMakeIntoFloat]\gb13Bi6u5U23I12i32I15i57I10i5u8U29I99i19Isolve1PointEqn: m | other matrix	["m should length 3"	other_Vector new: 3.	other1_m2.  other2_0.0-(m1).  other3_0.0.	matrix_Vector new: 2.	matrix1_m.  matrix2_other.	self solve2PointEqns: matrix]\gb18B18iu1U16Isolve2PointEqns: m | det x y	["m should be 2 by 3"	det_((m11) * (m22)) - ((m12) * (m21)).	det=0.0  		[0.0=(m11)[self solve1PointEqn: m2]		self solve1PointEqn: m1]	x _ ((m13) * (m22)) - ((m23) * (m12))		/ det.	y _ ((m11) * (m23)) - ((m21) * (m13))		/ det.	Point new x: x y: y]\gb19B13iu1U17IsolveMagnitude		| i matrix delta nConstraints negerrsum errchange x	["This message returns the change to be made to a Magnitude		to satisfy its constraints (1 degree of freedom).  The change is	   determined by finding linear equations which best approximate the	   possibly nonlinear constraints, given the current values of the	   variables.  Then a least-mean-squares fit to these equations is	   found.  See Ivan Sutherland's thesis Sketchpad for details of	   this technique.	   The global variable Incremented is set to true when the value of	   the object being relaxed has been incremented."	 nConstraints _ owners length.	 delta _ [0.0001 > object contents abs  [0.0001] 0.001 * object contents].	 1 = nConstraints 		[Incremented_false.		 negerrsum _ 0.0 - (owners1 performDangerously: errors1).		 self add: delta.  Incremented_true.		 errchange _ negerrsum + (owners1 performDangerously: errors1) / delta.		 self sub: delta.  Incremented_false.		 errchange = 0.0  [0.0]		 negerrsum/errchange]		 	 Incremented_false.	 matrix _ Vector new: nConstraints.	 for i to: nConstraints do		[matrixi _ Vector new: 2.		 matrixi2 _ 0.0 - (ownersi performDangerously: errorsi)].	 self add: delta.  Incremented_true.	 for i to: nConstraints do		[matrixi1 _ (matrixi2) + (ownersi performDangerously: errorsi)				/ delta].	 self sub: delta.  Incremented_false.	 negerrsum _ errchange _ 0.0.	 for i to: nConstraints do		[negerrsum _ (matrixi2) * (x _ matrixi1) + negerrsum.		 errchange _ x * x + errchange].	 errchange = 0.0  [0.0]	 negerrsum/errchange]\gb17B54i373u9U61u11U85IsolvePoint		| i matrix nConstraints	["This message returns the change to be made to a Point		to satisfy its constraints (2 degrees of freedom).  The change is	   determined by finding linear equations which best approximate the	   possibly nonlinear constraints, given the current values of the	   variables.  Then a least-mean-squares fit to these equations is	   found.  See Ivan Sutherland's thesis Sketchpad for details of	   this technique.	   The global variable Incremented is set to true when the value of	   the object being relaxed has been incremented."	 nConstraints _ owners length.	 Incremented_false.	 matrix _ Vector new: nConstraints.	 for i to: nConstraints do		[matrixi _ Vector new: 3.		 matrixi3 _ 0.0 - (ownersi performDangerously: errorsi)].	 self add: 10.  Incremented_true.	 for i to: nConstraints do		[matrixi1 _ (matrixi3) + (ownersi performDangerously: errorsi)].	 self add: 11.	 for i to: nConstraints do		[matrixi2 _ (matrixi3) + (ownersi performDangerously: errorsi)].	 self add: 01.  Incremented_false.	nConstraints=1[self solve1PointEqn: matrix1];		=2[self solve2PointEqns: matrix]		self solve2PointEqns: (self reducePointMatrix: matrix)]\gb13B26i370u9U61u11U85Isub: change	[object sub: change.	methodnone[]  context performDangerously: method]\gb13BtestConstraints   "return true if constraints are satisfied"		| i j 	[for i to: objects length do		[owners_ownerVecsi.  tests_testVecsi.		for j to: owners length do [ownersj perform: testsj[]  false]].	true]\gb18Bi42Itoterror   "compute the sum of the squares of the errors"		| toterror e i j 	[toterror _ 0.0.	for i to: objects length do		[owners_ownerVecsi.  errors_errorVecsi.		for j to: owners length do			[e _ ownersj perform: errorsj.			toterror _ e*e + toterror]].	toterror]\gb11Bi46IundoMakeIntoFloat | o	[for o from: objects do		[o undoMakeIntoFloat]]\gb18BclassInit\f5bgclassInit	[Smalltalk declare: Incremented as: false]\gb11B\gSystemOrganization classify: Relaxer under: 'ThingLab Constraints'.\gRelaxer classInit\g"BridgeRelaxer"l15000z20000\f5bgClass new title: 'BridgeRelaxer'	subclassof: Relaxer	fields: ''	declare: '';	asFollows\f5bgA BridgeRelaxer doesn't expect the error in the constraints to go to 0\igExecution\f5bgcheckError: toterror old: old   "true if relaxation should stop"	["this replaces the inherited method - doesn't put out a message		if constraints are not satisfied, and doesn't check for a decrease		in the total error"	( context minChange * toterror) > (old - toterror) abs]\gb32Bi33I3i154IprintError: error	["In bridges, the error is actually the sum of the squares		of the changes in lengths of the beams"	user cr; show: 'deformation: ' + error asString]\gb19B2i97ItestConstraints [false]\gb16B\gSystemOrganization classify: BridgeRelaxer under: 'ThingLab Constraints'.\g"SetConstraint"l15000z20000\f5bgClass new title: 'SetConstraint'	subclassof: Constraint	fields: 'element  "a string - formal name for set elements 								(used in elementMessage)"		set  "a string - converts to path to the constrained set"		elementMessage  "a string - message to be sent to update any element"'	declare: '';	asFollows\f5bgI am a constraint on the elements of a set.  I dont distinguish among the elements - they all get the same message.Kludgiferous limitations: the elementMessage must be of the form	element _ mumble, and must be uniqueState.\igInitialization\f5bgforEach: element in: set sendMessage: elementMessage | vec	["initialization - make a dummy message to elements for detecting 		overlap of constraints.  The elements are really altered rather than		referenced, but this message will be enough to cause this constraint		to be activated."	vec_elementMessage asVector.	vec1element unique or vec2_ 		[user notify: 'elementMessage not of proper form']	super messages_ (set + ' elements reference') inVector]\gb53B9i41u8U176ICompiling\f5bgaddMessages: queue context: context owner: owner receiver: receiver		| path setPaths copy strm newElement newSet arg	["add my messages to the queue"	(self overlaps: receiver)false []	"see if I have already been told to add messages to the queue"	queue hasConstraint: self owner: owner[]	setPaths_(owner concat: set asPath) applyTo: context.	for path from: setPaths do		["find paths to set and set elements in current context"		strm_Stream default.		(owner concat: set asPath) codeTo: strm.  newSet_strm contents.		strm_Stream default.		path codeTo: strm.  newElement_strm contents.		arg_'[' + elementMessage + ']'.		arg_arg subst: newElement for: element.		arg_arg subst: newSet for: set.		"make a copy of my message with the correct context, receiver,			and owner. Giant kludge: since the code compiled will send			this message to the owner of the constraint rather than the			constrained object, just ask if this owner is eq to the result of			actually doing the work.  All this is a mess - the messages should			compile code directly, not reference constraint methods.  Also, the			set should be expanded at compile time.  Last minute thesis hacks ..."		copy _ Message new			context: context receiver: path			constraint: self owner: owner			keywords: ('') arguments: arg inVector			uniqueState: true			referenceOnly: false			compileTimeOnly: false.		queue insert: copy.		copy addMessages: queue]]\gb70B51i28I41i60I134i53I275i469I\gSystemOrganization classify: SetConstraint under: 'ThingLab Constraints'.\g"SetMembershipConstraint"l15000z20000\f5bgClass new title: 'SetMembershipConstraint'	subclassof: Constraint	fields: 'element  "a string - path to set element"		set  "a string - path to set" '	declare: '';	asFollows\f5bgThis class has not yet been commented\igInitialization\f5bgset: set element: element	["initialization - make dummy messages for detecting 		overlap of constraints."	super messages_ (set + ' elements reference'), (element + ' reference')]\gb27B2i77ICompiling\f5bgaddMessages: queue context: context owner: owner receiver: receiver		| message copy	["add my messages to the queue"	(self overlaps: receiver)false []	"see if I have already been told to add messages to the queue"	queue hasConstraint: self owner: owner[]	for message from: messages do		["make a copy of my message with the correct context, receiver,			and owner"		copy _ Message new			context: context receiver: (owner concat: message receiver)			constraint: self owner: owner			keywords: message keywords arguments: message arguments			uniqueState: message uniqueState			referenceOnly: message referenceOnly			compileTimeOnly: message compileTimeOnly.		"kludge - only add first message"		[message(messages1)[queue insert: copy]].		copy addMessages: queue]]\gb70B18i28I41i60I82i74I302i31I\gSystemOrganization classify: SetMembershipConstraint under: 'ThingLab Constraints'.\g